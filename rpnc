#!/usr/bin/perl

#   Sinn: Commandline-Pocketcalculator
#  Autor: t3o 2023++

# DONE change the parser to read char by char in a mode like "number" or "string"
# DONE we need types of things on the stack
# TODO inv
# TODO ^
# TODO do we need 3 over (ovr) ? or "<n> copy"?
# DONE: Parser ändern, dass er zeichenweise liest, dabei in einem Modus wie zb "zahl" ist, oder "string"
# DONE brauchen (eigentlich) Typen für Dinge auf dem Stack (das koennte ein Package sein)

# TODO: Programmierfähigkeit -- unter einem Namen eine zu parsende Zeichenkette ablegen
# TODO: Hilfe einbauen
# TODO konstanten
#
use constant REVISION => "20231213";

# ==============================================================
package TheMachine;
use strict;
use warnings;
use Data::Dumper;
use YAML::Syck;

use constant SAVEFILE_VERSION => 2;
sub new
{
	my $classname = shift;
	my %params = @_;
	my $self = bless({}, $classname);

	$self->{ stack } = [];
	$self->{ vars  } = {};
	$self->{ flags } = {}; # TODO config vars (output format)
	$self->{ errors} = []; # collected errors, cleared when printed
	$self->{ loop  } = 4e4;
	$self->{ do_load_state } = ($params{'noload'} // 0) ? 0 : 1; # default: load_state
	$self->{ do_save_state } = ($params{'nosave'} // 0) ? 0 : 1;
	$self->{ statefile } = $params{statefile} // $ENV{"HOME"} . "/.rpnc";
	$self->load_state() if $self->{ do_load_state };
	$self->{ reserved } = {};
	map { $self->{ reserved }->{$_} = 1 } ("sin", "cos", "inv", "swap", "swp", "drop", "dup", "clear", "clr", "pi");
	return $self;
}

# --------------------------------------------------------
# load the machine state of last session
# TODO let the main package load the state and put it into the machine with setters
sub load_state
{
	my ($self) = @_;
	return unless -f $self->{ statefile };
	# print "Loading state from file '" . $self->{ statefile } . "'\n";
	my $state = LoadFile( $self->{ statefile } );
	if (! (defined( $state->{_version}) && ( $state->{_version} == $self->SAVEFILE_VERSION)))
	{
		die("state file version mismatch. I found >" . $state->{_version} . "< but I need >" . $self->SAVEFILE_VERSION . "<");
	}

	$self->{ stack } = $state->{ stack };
	$self->{ vars  } = $state->{ vars  };
	$self->{ flags } = $state->{ flags };
}

# --------------------------------------------------------
# push or better unshift element to stack
sub onto_stack
{
	my ($self, $atom) = @_;
	unshift( @{ $self->{ stack } }, $atom );
}

# --------------------------------------------------------
sub save_state
{
	my ($self) = @_;
	my $state = {
		_version => $self->SAVEFILE_VERSION,
		stack => $self->{ stack },
		vars  => $self->{ vars  },
		flags => $self->{ flags },
		revision => main->REVISION,
		comment => "statefile of the RPNC rpn calculator",
	};
	# print "Saving state " . Dumper( $state );
	DumpFile( $self->{ statefile }, $state );
}

# --------------------------------------------------------
sub shutdown
{
	my ($self) = @_;
	$self->save_state() if $self->{ do_save_state };
}

# --------------------------------------------------------
sub do
{
	my ($self, $atom) = @_;
	my $type = $atom->{ type };
	if ($type eq Parser->OPERATOR)
	{
		$self->operate( $atom );
	}
	elsif ($type eq Parser->NUMBER)
	{
		$self->onto_stack( $atom );
	}
	else {
		$self->error("Unknown atom type '$type' with value '" . $atom->{ value } . "'. Skipped.");
	}
}

# --------------------------------------------------------
sub error
{
	my ($self, $message) = @_;
	push( @{ $self->{errors} }, $message );
}


# --------------------------------------------------------
# add two number of type Parser->NUMBER
sub add
{
	my $self = shift;
	my %params = @_;
	my $invert = defined($params{"invert"}) && $params{invert} ? 1 : 0;
	if ($self->has_two_numbers())
	{
		my $b = shift( @{ $self->{ stack } } );
		$b->{value} = -1 * $b->{value} if $invert;
		my $a = shift( @{ $self->{ stack } } );
		$self->onto_stack( {type => Parser->NUMBER, value => $a->{ value } + $b->{ value } } );
	}
}

# --------------------------------------------------------
sub mul
{
	my $self = shift;
	my %params = @_;
	my $invert = defined($params{"invert"}) && $params{invert} ? 1 : 0;
	if ($self->has_two_numbers())
	{
		my $b = shift( @{ $self->{ stack } } ); # consume atoms
		my $a = shift( @{ $self->{ stack } } ); # consume
		if ($invert)
		{
			if ($b->{ value } == 0)
			{
				$self->error("division by zero");
			}
			else {
				$self->onto_stack( {type => Parser->NUMBER, value => $a->{ value } / $b->{ value } } );
			}
		}
		else {
			$self->onto_stack( {type => Parser->NUMBER, value => $a->{ value } * $b->{ value } } );
		}
	}
}

# --------------------------------------------------------
# copy stack element idx and push it on stack
#
# #2  3.14
# #1  234
# #0  0.3
#
# now: "3 cp":
#
# #3  15
# #2  12
# #1  3
# #0  cp
#
# -> will take the value of the element that is on index 3 after removing "cp" and "3".
#sub copy
#{
#	my $self = shift;
#	if ($self->idx_is_number(0)) # cmd was there before
#	{
#		BAUSTELLE
#		my $index = shift( @{ $self->{ stack } } ); # consume atom
#		$self->onto_stack( {type => Parser->NUMBER, value => $index->{value} } );
#	}
#}


# --------------------------------------------------------
sub has_two_numbers
{
	my $self = shift;
	if ($self->idx_is_number(0) && $self->idx_is_number(1))
	{
		return 1;
	}

	push( @{ $self->{errors} }, "not two numbers on stack" );
	return 0;
}

# is stack place #3 there and is it a number?
# is it counting from 0? yes (why? because it is the index of the element)
sub idx_is_number
{
	my ($self, $index) = @_;
	return 0 if scalar@{ $self->{ stack }} >= ($index + 1);
	return 0 if ($self->{ stack }->[ $index ]->{ type } ne Parser->NUMBER);
	return 1;
}

# --------------------------------------------------------
sub operate
{
	my ($self, $atom) = @_;
	my $type = $atom->{ type };
	my $operation = $atom->{ value };
	if ($type eq Parser->OPERATOR)
	{
		if ($operation eq "+")
		{
			$self->add();
			return;
		}
		elsif ($operation eq "-")
		{
			$self->add( invert => 1 );
			return;
		}
		elsif ($operation eq "*")
		{
			$self->mul();
			return;
		}
		elsif ($operation eq "/")
		{
			$self->mul( invert => 1 );
			return;
		}
		elsif (($operation eq "drop") || ($operation eq "d"))
		{
			if (scalar @{ $self->{ stack }} > 0)
			{
				shift( @{ $self->{ stack } } );
			}
		}
		elsif ($operation eq "swap")
		{
			if (scalar @{ $self->{ stack }} >= 2)
			{
				my $b = shift( @{ $self->{ stack }} );
				my $a = shift( @{ $self->{ stack }} );
				$self->onto_stack( $b );
				$self->onto_stack( $a );
			}
		}
		elsif (($operation eq "clear") || ($operation eq "clr"))
		{
			$self->{ stack } = [];
		}
		else {
			die("unknown operation >$operation<");
		}
	}
	else
	{
		die("Unknown type '$type' in ->operate");
	}
}

# ----------------------------------------------------------------------------
sub show
{
	my ($self) = shift;

	my $vars = $self->{ vars };
	if (scalar keys %{ $vars })
	{
		my $s = "";
		map { $s .= "$_=" . $vars->{ $_ } . " " } sort keys %{ $vars };
		print "VARS: " . substr($s, 0, -1) . "\n";
	}
	
	print "Stack:\n";
	my $stack = $self->{ stack };
	# print "stack in wrong order :-) : " . Dumper($stack);
	my $number = scalar @{ $stack };
	
	for (my $i = $number - 1; $i >= 0; $i--)
	{
		my $atom = $stack->[ $i ];
		if ($atom->{type} eq Parser->NUMBER)
		{
			printf("  %2s : %s\n", '#' . $i, $atom->{value}); # TODO add format
		}
		else {
			printf("  %2s : %s\n", '#' . $i, "unknown entity: " . Dumper($atom));
		}
	}
	print "  -empty-\n" unless $number;
	
	if (@{ $self->{ errors } } > 0)
	{
		map { print "ERROR: $_\n" } @{ $self->{ errors } };
		$self->{ errors } = [];
	}
	print "INPUT> ";
}

1;

# ==============================================================
package Parser;
use strict;
use warnings;

use constant END_OF_STREAM => "end-of-stream";
use constant NUMBER => "number";
use constant OPERATOR => "operator";
use constant STRING => "string";
use constant SYMBOL => "symbol";
use constant UNKNOWN => "unknown";

# static function
sub next_atom
{
	my $stream = shift;
	$stream =~ s/^ //g;
	if (! length($stream))
	{
		return [{type => Parser->END_OF_STREAM, value => "moo"}, ""];
	}
	if ($stream =~ /^(-[0-9]+([\.][0-9]+)?)(.*)/)
	{
		return [{type => Parser->NUMBER, value => $1}, $3]; # negative number
	}
	elsif ($stream =~ /^([0-9]+([\.][0-9]+)?)(.*)/)
	{
		return [{type => Parser->NUMBER, value => $1}, $3]; # positive number
	}
	elsif ($stream =~ /^([\/\*\-\+])(.*)/)
	{
		return [{type => Parser->OPERATOR, value => $1}, $2]; # operator
	}
	elsif ($stream =~ /^(clr|clear|vars|q|dump|drop|d|swap)(.*)/)
	{
		return [{type => Parser->OPERATOR, value => $1}, $2]; # internal operation
	}
	elsif ($stream =~ /^"([^"]*)"(.*)/)
	{
		return [{type => Parser->STRING, value => $1}, $2]; # string object
	}
	elsif ($stream =~ /^'([^']*)'(.*)/)
	{
		return [{type => Parser->STRING, value => $1}, $2]; # string object
	}
	elsif ($stream =~ /^([a-zA-Z][a-zA-Z0-9_]*)(.*)/)
	{
		return [{type => Parser->SYMBOL, value => $1}, $2]; # vars/symbol
	}
	return [{type => Parser->UNKNOWN, value => $stream}, ""];
}
1;

# ==============================================================
package main;

use strict;
use warnings;
use Data::Dumper;
use Getopt::Long;
use YAML::Syck;
use Test::More;
use Test::Exception;
#use Parser;
#use TheMachine;

$|=1;
$Data::Dumper::Sortkeys = 1;

GetOptions(
	'help|h' => \my $need_help,
	'test' => \my $do_tests,
	'nosave' => \my $nosave,         # default: false
	'noload' => \my $noload,         # default: false
	'statefile=s' => \my $statefile, # default: HOME/.rpnc
	# 'quiet'  => \my $be_quiet,
);
usage() if $need_help;
if ($do_tests)
{
	note("--+- performing tests -+--");
	# test__is_allowed_system_name();
	is_deeply( Parser::next_atom("54321"), [{type => Parser->NUMBER, value => "54321"}, ""], "Parser::next_atom" );
	is_deeply( Parser::next_atom("3.14159"), [{type => Parser->NUMBER, value => "3.14159"}, ""], "Parser::next_atom" );
	is_deeply( Parser::next_atom("5+"), [{type => Parser->NUMBER, value => "5"}, "+"], "Parser::next_atom" );

	my $s = "3.6 1.8/";
	my $r = Parser::next_atom( $s );
	is_deeply( $r, [{type => Parser->NUMBER, value => "3.6"}, " 1.8/"], "Parser::next_atom $s" );

	$s = $r->[1];
	$r = Parser::next_atom( $s );
	is_deeply( $r, [{type => Parser->NUMBER, value => "1.8"}, "/"], "Parser::next_atom $s" );

	$s = $r->[1];
	$r = Parser::next_atom( $s );
	is_deeply( $r, [{type => Parser->OPERATOR, value => "/"}, ""], "Parser::next_atom $s" );

	$s = $r->[1]; # Expected end
	$r = Parser::next_atom( $s );
	is_deeply( $r, [{type => Parser->END_OF_STREAM, value => "moo"}, ""], "END_OF_STREAM" );

	is_deeply( Parser::next_atom("clear5+"), [{type => Parser->OPERATOR, value => "clear"}, "5+"], "Parser::next_atom / clear" );
	is_deeply( Parser::next_atom("clr6+")  , [{type => Parser->OPERATOR, value => "clr"}, "6+"], "Parser::next_atom / clear" );
	is_deeply( Parser::next_atom("fahrenheit")  , [{type => Parser->SYMBOL, value => "fahrenheit"}, ""], "Parser::next_atom / symbol" );
	is_deeply( Parser::next_atom("fahrenheit*")  , [{type => Parser->SYMBOL, value => "fahrenheit"}, "*"], "Parser::next_atom / symbol" );

	done_testing;
	exit(0);
}
Test::More->builder->reset;

print "Welcome to the wunderful world of R-P-N-C\n";
my $rpnc = TheMachine->new(
	nosave => $nosave,
	noload => $noload,
	statefile => $statefile,
);
my $loop = 434;
while ($loop)
{
	$rpnc->show();
	my $input = <STDIN>;
	unless (defined $input) # Ctrl-d
	{
		print "\n";
		last;
	}
	chomp($input);

	my $atom;
	while(434)
	{
		my $thingy = Parser::next_atom( $input );
		$atom  = $thingy->[0];
		$input = $thingy->[1];
		# print " DEBUGGING atom from stream: " . Dumper($atom);
		my $type = $atom->{ type };
		last if $type eq Parser->END_OF_STREAM;
		if (($type eq Parser->OPERATOR) && ($atom->{value} eq "q")) # quit
		{
			$loop = 0;
			last;
		}
		else {
			$rpnc->do( $atom ); # handle NUMBER OPERATOR
		}
	}
}
$rpnc->shutdown();
exit(0);

# ----------------------------------------------------------------------------
sub usage
{
	my $msg = shift;
	print "$0 REVISION " . REVISION . "\n";
	print "ERROR: $msg\n" if defined $msg;
	print "Usage: $0 ....\n";
	exit(1);
}

