#!/usr/bin/perl

#   Sinn: Commandline-Taschenrechner
#  Autor: t3o

# -> + einbauen

# DONE: Parser ändern, dass er zeichenweise liest, dabei in einem Modus wie zb "zahl" ist, oder "string"
# TODO: brauchen (eigentlich) Typen für Dinge auf dem Stack

# TODO: rechner als package/object organisiern, um Testfunktionen schreiben zu koennen

# TODO: Programmierfähigkeit -- unter einem Namen eine zu parsende Zeichenkette ablegen
# TODO: ggf alles nach STDERR ausgeben, um im Batchmode stdout auswerrten zu koennen. ODER --quiet einbauen
# TODO: Hilfe einbauen
# TODO konstanten
#
use constant REVISION => "20231124";

# ==============================================================
package TheMachine;
use strict;
use warnings;
use Data::Dumper;
use YAML::Syck;

sub new
{
	my $classname = shift;
	my %params = @_;
	my $self = bless({}, $classname);

	$self->{ stack } = [];
	$self->{ vars  } = {};
	$self->{ flags } = {}; # TODO config vars (output format)
	$self->{ errors} = []; # collected errors, cleared when printed
	$self->{ loop  } = 4e4;
	$self->{ persistent }  = defined( $params{"persistent"} ) && $params{"persistent"} ? 1 : 0;
	$self->{ statefile } = $ENV{"HOME"} . "/.rpnc";
	$self->load_state() if $self->{ persistent };
	$self->{ reserved } = {};
	map { $self->{ reserved }->{$_} = 1 } ("sin", "cos", "inv", "swap", "swp", "drop", "dup", "clear", "clr", "pi");
	return $self;
}

sub load_state
{
	my ($self) = @_;
	return unless -f $self->{ statefile };
	my $state = LoadFile( $self->{ statefile } );
	$self->{ stack } = $state->{ stack };
	$self->{ vars  } = $state->{ vars  };
	$self->{ flags } = $state->{ flags };
}

# push or better unshift element to stack
sub onto_stack
{
	my ($self, $atom) = @_;
	unshift( @{ $self->{ stack } }, $atom );
}

sub save_state
{
	my ($self) = @_;
	my $state = {
		stack => $self->{ stack },
		vars  => $self->{ vars  },
		flags => $self->{ flags },
		revision => main->REVISION,
		comment => "statefile of the RPNC rpn calculator",
	};
	DumpFile( $self->{ statefile }, $state );
}

sub shutdown
{
	my ($self) = @_;
	$self->save_state() if $self->{ persistent };
}

# add two number of type Parser->NUMBER
sub add
{
	my ($self) = @_;
	if ($self->has_two_numbers())
	{
		my $b = shift( @{ $self->{ stack } } );
		my $a = shift( @{ $self->{ stack } } );
		$self->onto_stack( {type => Parser->NUMBER, value => $a->{ value } + $b->{ value } } );
	}
}

sub has_two_numbers
{
	my $self = shift;
	if (scalar @{ $self->{ stack }} < 2)
	{
		push( @{ $self->{errors} }, "stack underflow, needed 2 elements" );
		return 0;
	}
	if (($self->{ stack }->[0]->{ type } eq Parser->NUMBER)
	&&  ($self->{ stack }->[1]->{ type } eq Parser->NUMBER))
	{
		return 1;
	}
	push( @{ $self->{errors} }, "not both elements are numbers" );
	return 0;
}

sub operate
{
	my ($self, $atom) = @_;
	die("Not an " . Parser->OPERATOR) unless $atom->{ type } eq Parser->OPERATOR;
	my $operation = $atom->{ value };
	if ($operation eq "+")
	{
		$self->add();
		return;
	}
	else {
		die("unknown operation >$operation<");
	}
	# TODO add more operators
}

# ----------------------------------------------------------------------------
sub show
{
	my ($self) = shift;

	my $vars = $self->{ vars };
	if (scalar keys %{ $vars })
	{
		my $s = "";
		map { $s .= "$_=" . $vars->{ $_ } . " " } sort keys %{ $vars };
		print "VARS: " . substr($s, 0, -1) . "\n";
	}
	
	print "Stack:\n";
	my $stack = $self->{ stack };
	# print "stack in wrong order :-) : " . Dumper($stack);
	my $number = scalar @{ $stack };
	
	for (my $i = $number - 1; $i >= 0; $i--)
	{
		my $atom = $stack->[ $i ];
		if ($atom->{type} eq Parser->NUMBER)
		{
			printf("  #%2s : %s\n", $i, $atom->{value}); # TODO add format
		}
		else {
			printf("  #%2s : %s\n", $i, "unknown entity: " . Dumper($atom));
		}
	}
	print "  -empty-\n" unless $number;
	
	if (@{ $self->{ errors } } > 0)
	{
		map { print "ERROR: $_\n" } @{ $self->{ errors } };
		$self->{ errors } = [];
	}
	print "INPUT> ";
}

1;

# ==============================================================
package Parser;
use strict;
use warnings;

use constant END_OF_STREAM => "end-of-stream";
use constant NUMBER => "number";
use constant OPERATOR => "operator";
use constant INTERNAL => "internal";
use constant STRING => "string";
use constant SYMBOL => "symbol";

# static function
sub next_atom
{
	my $stream = shift;
	$stream =~ s/^ //g;
	if (! length($stream))
	{
		return [{type => Parser->END_OF_STREAM, value => "moo"}, ""];
	}
	if ($stream =~ /^(-[0-9]+([\.][0-9]+)?)(.*)/)
	{
		return [{type => Parser->NUMBER, value => $1}, $3]; # negative number
	}
	elsif ($stream =~ /^([0-9]+([\.][0-9]+)?)(.*)/)
	{
		return [{type => Parser->NUMBER, value => $1}, $3]; # positive number
	}
	elsif ($stream =~ /^([\/\*\-\+])(.*)/)
	{
		return [{type => Parser->OPERATOR, value => $1}, $2]; # operator
	}
	elsif ($stream =~ /^(clr|clear|vars|q|dump|drop|d)(.*)/)
	{
		return [{type => Parser->INTERNAL, value => $1}, $2]; # internal operation
	}
	elsif ($stream =~ /^"([^"]*)"(.*)/)
	{
		return [{type => Parser->STRING, value => $1}, $2]; # string object
	}
	elsif ($stream =~ /^'([^']*)'(.*)/)
	{
		return [{type => Parser->STRING, value => $1}, $2]; # string object
	}
	elsif ($stream =~ /^([a-zA-Z][a-zA-Z0-9_]*)(.*)/)
	{
		return [{type => Parser->SYMBOL, value => $1}, $2]; # vars/symbol
	}
	return [{type => Parser->UNKNOWN, value => $stream}, ""];
}
1;

# ==============================================================
package main;

use strict;
use warnings;
use Data::Dumper;
use YAML::Syck;
use Test::More;
use Test::Exception;
#use Parser;
#use TheMachine;

$|=1;
$Data::Dumper::Sortkeys = 1;

use Getopt::Long;
GetOptions(
	'help|h' => \my $need_help,
	'test' => \my $do_tests,
	'nosave' => \my $nosave,
	# 'quiet'  => \my $be_quiet,
);
usage() if $need_help;
if ($do_tests)
{
	note("--+- performing tests -+--");
	# test__is_allowed_system_name();
	is_deeply( Parser::next_atom("54321"), [{type => Parser->NUMBER, value => "54321"}, ""], "Parser::next_atom" );
	is_deeply( Parser::next_atom("3.14159"), [{type => Parser->NUMBER, value => "3.14159"}, ""], "Parser::next_atom" );
	is_deeply( Parser::next_atom("5+"), [{type => Parser->NUMBER, value => "5"}, "+"], "Parser::next_atom" );

	my $s = "3.6 1.8/";
	my $r = Parser::next_atom( $s );
	is_deeply( $r, [{type => Parser->NUMBER, value => "3.6"}, " 1.8/"], "Parser::next_atom $s" );

	$s = $r->[1];
	$r = Parser::next_atom( $s );
	is_deeply( $r, [{type => Parser->NUMBER, value => "1.8"}, "/"], "Parser::next_atom $s" );

	$s = $r->[1];
	$r = Parser::next_atom( $s );
	is_deeply( $r, [{type => Parser->OPERATOR, value => "/"}, ""], "Parser::next_atom $s" );

	$s = $r->[1]; # Expected end
	$r = Parser::next_atom( $s );
	is_deeply( $r, [{type => Parser->END_OF_STREAM, value => "moo"}, ""], "END_OF_STREAM" );

	is_deeply( Parser::next_atom("clear5+"), [{type => Parser->INTERNAL, value => "clear"}, "5+"], "Parser::next_atom / clear" );
	is_deeply( Parser::next_atom("clr6+")  , [{type => Parser->INTERNAL, value => "clr"}, "6+"], "Parser::next_atom / clear" );
	is_deeply( Parser::next_atom("fahrenheit")  , [{type => Parser->SYMBOL, value => "fahrenheit"}, ""], "Parser::next_atom / symbol" );
	is_deeply( Parser::next_atom("fahrenheit*")  , [{type => Parser->SYMBOL, value => "fahrenheit"}, "*"], "Parser::next_atom / symbol" );

	done_testing;
	exit(0);
}
Test::More->builder->reset;

print "Welcome to the wunderful world of R-P-N-C\n";
my $rpnc = TheMachine->new( persistent => $nosave ? 0 : 1 );
my $loop = 434;
while ($loop)
{
	$rpnc->show();
	my $input = <STDIN>;
	unless (defined $input) # Ctrl-d
	{
		print "\n";
		last;
	}
	chomp($input);

	my $atom;
	while(434)
	{
		my $thingy = Parser::next_atom( $input );
		$atom  = $thingy->[0];
		$input = $thingy->[1];
		print " ATOM " . Dumper($atom);
		my $type = $atom->{ type };
		last if $type eq Parser->END_OF_STREAM;
		if ($type eq Parser->INTERNAL)
		{
			if ($atom->{value} eq "q") # quit
			{
				$loop = 0;
				last;
			}
		}
		elsif ($type eq Parser->NUMBER)
		{
			$rpnc->onto_stack( $atom );
		}
		elsif ($type eq Parser->OPERATOR)
		{
			$rpnc->operate( $atom );
		}
	}
}
$rpnc->shutdown();
exit(0);



# ----------------------------------------------------------------------------
sub assert_one_element_on_stack
{
	my $data = shift;
	if (scalar @{ $data->{ stack } })
	{
		return 1;
	}
	push( @{ $data->{errors} }, "stack underflowi (1)" );
	return 0;
}
# ----------------------------------------------------------------------------
sub assert_two_elements_on_stack
{
	my $data = shift;
	if (scalar @{ $data->{ stack } } >= 2)
	{
		return 1;
	}
	push( @{ $data->{errors} }, "stack underflow" );
	return 0;
}

# ----------------------------------------------------------------------------
sub usage
{
	my $msg = shift;
	print "$0 REVISION " . REVISION . "\n";
	print "ERROR: $msg\n" if defined $msg;
	print "Usage: $0 ....\n";
	exit(1);
}

